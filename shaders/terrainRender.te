#version 400 core

layout (quads, fractional_odd_spacing) in;

uniform sampler2D terrainTexture;
uniform mat4 projMatrix;
uniform mat4 mvMatrix;

in TCS_OUT
{
    vec2 tc;
} tes_in[];

smooth out vec2 tc;
flat out float scaleFactor;

void main(void)
{
    // Our scaling factor is based on the height of the contours. 
    // The maximum height is ~8000 feet, minimum ~600 feet. This gives ~900 total feet, 
    const float depth = 900;
    
    // Get an average texture coordinate over the quad
    vec2 tc1 = mix(tes_in[0].tc, tes_in[1].tc, gl_TessCoord.x);
    vec2 tc2 = mix(tes_in[2].tc, tes_in[3].tc, gl_TessCoord.x);
    vec2 tc = mix(tc2, tc1, gl_TessCoord.y);
        
    // Get an average position using the same logic as above.
    vec4 pos1 = mix(gl_in[0].gl_Position, gl_in[1].gl_Position, gl_TessCoord.x);
    vec4 pos2 = mix(gl_in[2].gl_Position, gl_in[3].gl_Position, gl_TessCoord.x);
    vec4 pos = mix(pos2, pos1, gl_TessCoord.y);
    
    // Note that as the terrain texture only contains height, so 'r' is the only valid (0-1) component.
    pos.z += texture(terrainTexture, tc).r * depth;
        
    gl_Position = projMatrix * mvMatrix * pos;    
    tc = tc;
    
    float t1 = texture(terrainTexture, tes_in[0].tc).r * depth;
    float t2 = texture(terrainTexture, tes_in[1].tc).r * depth;
    float t3 = texture(terrainTexture, tes_in[2].tc).r * depth;
    float t4 = texture(terrainTexture, tes_in[3].tc).r * depth;
    float maxH = max(t1, max(t2, max(t3, t4)));
    float minH = min(t1, min(t2, min(t3, t4)));
    
    scaleFactor = cos(atan(maxH - minH));
}


