#version 400 core

layout (quads, fractional_odd_spacing) in;

uniform sampler2D terrainTexture;

uniform mat4 projMatrix;
uniform mat4 mvMatrix;

in vec2 tes_in[];

smooth out vec2 tc_fs;
smooth out vec3 fragment_position;
flat out float scaleFactor;

void main(void)
{
    // Our scaling factor is based on the height of the contours. 
    // The maximum height is ~8000 feet, minimum ~600 feet. This gives ~900 total feet, 
    const float depth = 900;
    
    // Get an average texture coordinate over the quad
    vec2 tc1 = mix(tes_in[0], tes_in[1], gl_TessCoord.x);
    vec2 tc2 = mix(tes_in[2], tes_in[3], gl_TessCoord.x);
    vec2 tc = mix(tc2, tc1, gl_TessCoord.y);
        
    // Get an average position using the same logic as above.
    vec4 pos1 = mix(gl_in[0].gl_Position, gl_in[1].gl_Position, gl_TessCoord.x);
    vec4 pos2 = mix(gl_in[2].gl_Position, gl_in[3].gl_Position, gl_TessCoord.x);
    vec4 pos = mix(pos2, pos1, gl_TessCoord.y);
    
    // Note that as the terrain texture only contains height, so 'r' is the only valid (0-1) component.
    pos.z += texelFetch(terrainTexture, ivec2(tc.x * 100, tc.y * 100), 0).r * depth;
    
    gl_Position = projMatrix * mvMatrix * pos;  
    fragment_position = vec3(gl_Position);	
    tc_fs = tc;
    
    float t1 = texelFetch(terrainTexture, ivec2(tes_in[0].x * 100, tes_in[0].y * 100), 0).r * depth;
    float t2 = texelFetch(terrainTexture, ivec2(tes_in[1].x * 100, tes_in[1].y * 100), 0).r * depth;
    float t3 = texelFetch(terrainTexture, ivec2(tes_in[2].x * 100, tes_in[2].y * 100), 0).r * depth;
    float t4 = texelFetch(terrainTexture, ivec2(tes_in[3].x * 100, tes_in[3].y * 100), 0).r * depth;
    float maxH = max(t1, max(t2, max(t3, t4)));
    float minH = min(t1, min(t2, min(t3, t4)));
    
    scaleFactor = cos(atan(maxH - minH));
}


